<!-- public/admin.html -->
<!DOCTYPE html>
<html>
<head>
  <title>é»‘åå•ç®¡ç†</title>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    input, button { padding: 8px; margin: 5px; }
    table { border-collapse: collapse; width: 100%; }
    th, td { padding: 8px; text-align: left; border: 1px solid #ddd; }
  </style>
</head>
<body>
  <h2>ğŸŒ é»‘åå•ç®¡ç†</h2>
  <form id="addForm" onsubmit="addBlacklist(event); return false;" style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
    <input type="text" id="domain" placeholder="åŸŸåï¼ˆå¦‚ï¼šqq.comï¼‰" required autocomplete="off" style="flex:1;">
    <input type="text" id="reason" placeholder="åŸå› ï¼ˆå¯é€‰ï¼Œä¾‹å¦‚ï¼šæ•™å­¦ç¦æ­¢ï¼‰" style="width:260px;">
    <button type="submit">â• æ·»åŠ </button>
  </form>

  <div style="display:flex; gap:8px; align-items:center; margin-bottom:10px;">
    <div style="flex:1;">
      <input id="search" placeholder="æœç´¢åŸŸå/åŸå› ï¼ˆæ¨¡ç³ŠåŒ¹é…ï¼‰" style="width:100%; padding:8px;" />
    </div>
    <div>
      æ¯é¡µï¼š
      <select id="pageSize">
        <option>10</option>
        <option selected>25</option>
        <option>50</option>
      </select>
    </div>
  </div>

  <p id="preview" style="color:#555; margin-top:6px;">å®æ—¶é¢„è§ˆï¼š<span id="preview-text">ï¼ˆè¯·è¾“å…¥åŸŸåï¼‰</span></p>

  <table id="list">
    <thead><tr><th>åŸŸå</th><th>åŸå› </th><th>åˆ›å»ºæ—¶é—´</th><th>æ“ä½œ</th></tr></thead>
    <tbody></tbody>
  </table>

  <script>
    const listBody = document.querySelector('#list tbody');
    const domainInput = document.getElementById('domain');
    const previewText = document.getElementById('preview-text');
    const reasonInput = document.getElementById('reason');
    const searchInput = document.getElementById('search');
    const pageSizeSelect = document.getElementById('pageSize');

    let pendingRows = new Map(); // key -> tr for optimistic rows

    function renderRow(item) {
      const tr = document.createElement('tr');
      tr.dataset.id = item.id || '';
      tr.innerHTML = `
        <td>${escapeHtml(item.domain)}</td>
        <td>${escapeHtml(item.reason || '')}</td>
        <td>${escapeHtml(item.created_at || '')}</td>
        <td><button data-id="${item.id}" class="del-btn">ğŸ—‘ï¸ åˆ é™¤</button></td>
      `;
      const btn = tr.querySelector('.del-btn');
      btn.addEventListener('click', () => removeDomain(item.id, item.domain, tr));
      return tr;
    }

    function escapeHtml(s) {
      if (!s) return '';
      return String(s).replace(/[&<>\"']/g, function (c) {
        return {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[c];
      });
    }

    // fullRows: the complete list fetched from server
    let fullRows = [];
    // paging state
    let currentPage = 1;

    async function loadList() {
      try {
        const res = await fetch('/api/blacklist/domains');
        if (!res.ok) throw new Error('HTTP ' + res.status);
        fullRows = await res.json();
        listBody.innerHTML = '';
        renderPage();
        // re-append any pending rows (optimistic)
        for (const [key, tr] of pendingRows) {
          listBody.insertBefore(tr, listBody.firstChild);
        }
      } catch (err) {
        console.error('åŠ è½½é»‘åå•å¤±è´¥', err);
        listBody.innerHTML = `<tr><td colspan="4" style="color:#d32f2f;">åŠ è½½å¤±è´¥ï¼š${err.message}</td></tr>`;
      }
    }

    function applyFilter(rows) {
      const q = (searchInput.value || '').trim().toLowerCase();
      if (!q) return rows;
      return rows.filter(r => (r.domain || '').toLowerCase().includes(q) || (r.reason || '').toLowerCase().includes(q));
    }

    function renderPage() {
      const pageSize = Number(pageSizeSelect.value || 25);
      const filtered = applyFilter(fullRows);
      const total = filtered.length;
      const totalPages = Math.max(1, Math.ceil(total / pageSize));
      if (currentPage > totalPages) currentPage = totalPages;
      const start = (currentPage - 1) * pageSize;
      const pageRows = filtered.slice(start, start + pageSize);
      listBody.innerHTML = '';
      pageRows.forEach(item => listBody.appendChild(renderRow(item)));
      // add paging footer row
      const footerTr = document.createElement('tr');
      footerTr.innerHTML = `<td colspan="4" style="text-align:right;padding:8px;">
        å…± ${total} æ¡ï¼Œé¡µ ${currentPage}/${totalPages} &nbsp;
        <button id="prevBtn" ${currentPage<=1? 'disabled':''}>ä¸Šä¸€é¡µ</button>
        <button id="nextBtn" ${currentPage>=totalPages? 'disabled':''}>ä¸‹ä¸€é¡µ</button>
      </td>`;
      listBody.appendChild(footerTr);
      document.getElementById('prevBtn').addEventListener('click', () => { currentPage = Math.max(1, currentPage-1); renderPage(); });
      document.getElementById('nextBtn').addEventListener('click', () => { currentPage = Math.min(totalPages, currentPage+1); renderPage(); });
      // re-append pending optimistic rows on top
      for (const [key, tr] of pendingRows) {
        listBody.insertBefore(tr, listBody.firstChild);
      }
    }

    // input preview
    domainInput.addEventListener('input', (e) => {
      const v = e.target.value.trim();
      previewText.textContent = v ? v : 'ï¼ˆè¯·è¾“å…¥åŸŸåï¼‰';
    });
    // search & paging events
    searchInput.addEventListener('input', () => { currentPage = 1; renderPage(); });
    pageSizeSelect.addEventListener('change', () => { currentPage = 1; renderPage(); });

    async function addBlacklist(e) {
      e.preventDefault();
      const domain = domainInput.value.trim();
      if (!domain) return;

      // create optimistic row
      const tempKey = 'pending:' + Date.now();
      const tr = document.createElement('tr');
      tr.className = 'pending';
      tr.innerHTML = `
        <td>${escapeHtml(domain)} <small style="color:#1976d2;">ï¼ˆæ­£åœ¨æ·»åŠ ...ï¼‰</small></td>
        <td></td>
        <td></td>
        <td><button disabled>...</button></td>
      `;
      pendingRows.set(tempKey, tr);
      listBody.insertBefore(tr, listBody.firstChild);
      domainInput.value = '';
      previewText.textContent = 'ï¼ˆè¯·è¾“å…¥åŸŸåï¼‰';

      try {
          const resp = await fetch('/api/blacklist/domains/add', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ domain, reason: reasonInput.value.trim() })
          });
        const data = await resp.json();
        if (!resp.ok) throw new Error(data.error || JSON.stringify(data));

        // server returned ok or message. Refresh list to get server-assigned id
        pendingRows.delete(tempKey);
        await loadList();
      } catch (err) {
        // remove optimistic row and show error message
        pendingRows.delete(tempKey);
        if (tr.parentNode) tr.parentNode.removeChild(tr);
        alert('æ·»åŠ å¤±è´¥ï¼š' + (err.message || err));
      }
    }

    async function removeDomain(id, domain, tr) {
      if (!confirm(`ç¡®å®šåˆ é™¤ ${domain}ï¼Ÿ`)) return;
      try {
        const resp = await fetch(`/api/blacklist/domains/${id}`, { method: 'DELETE' });
        if (!resp.ok) {
          const txt = await resp.text();
          throw new Error(txt || resp.statusText);
        }
        // remove row
        if (tr && tr.parentNode) tr.parentNode.removeChild(tr);
      } catch (err) {
        alert('åˆ é™¤å¤±è´¥ï¼š' + (err.message || err));
      }
    }

    // initial load
    loadList();
  </script>
</body>
</html>